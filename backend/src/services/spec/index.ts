import { v4 as uuidv4 } from "uuid"
import { Not } from "typeorm"
import SwaggerParser from "@apidevtools/swagger-parser"
import yaml from "js-yaml"
import OpenAPIRequestValidator from "@leoscope/openapi-request-validator"
import OpenAPIResponseValidator, {
  OpenAPIResponseValidatorValidationError,
} from "@leoscope/openapi-response-validator"
import { AlertType, RestMethod, SpecExtension } from "@common/enums"
import {
  ApiEndpoint,
  ApiTrace,
  DataField,
  OpenApiSpec,
  Alert,
  AggregateTraceData,
} from "models"
import { JSONValue, OpenApiSpec as OpenApiSpecResponse } from "@common/types"
import { getPathTokens } from "@common/utils"
import { AppDataSource } from "data-source"
import { getPathRegex, isParameter, parsedJsonNonNull } from "utils"
import Error409Conflict from "errors/error-409-conflict"
import Error422UnprocessableEntity from "errors/error-422-unprocessable-entity"
import {
  generateAlertMessageFromReqErrors,
  generateAlertMessageFromRespErrors,
  getOpenAPISpecVersion,
  getSpecRequestParameters,
  getSpecResponses,
  parsePathParameter,
  SpecValue,
  AjvError,
  validateSpecSchema,
  getSpecRequestBody,
  getHostsV3,
  getServersV3,
  getHostsV2,
} from "./utils"
import { AlertService } from "services/alert"
import { DatabaseService } from "services/database"
import Error404NotFound from "errors/error-404-not-found"
import { BlockFieldsService } from "services/block-fields"

export class SpecService {
  static async getSpec(specName: string): Promise<OpenApiSpecResponse> {
    const openApiSpecRepository = AppDataSource.getRepository(OpenApiSpec)
    const spec = await openApiSpecRepository.findOneBy({ name: specName })
    return spec
  }

  static async getSpecs(
    listAutogenerated: boolean = true,
  ): Promise<OpenApiSpecResponse[]> {
    const openApiSpecRepository = AppDataSource.getRepository(OpenApiSpec)
    const specList = await openApiSpecRepository.find({
      where: { isAutoGenerated: listAutogenerated },
      order: { updatedAt: "DESC" },
    })
    return specList
  }

  static async updateSpec(
    specObject: JSONValue,
    fileName: string,
    extension: SpecExtension,
    specString: string,
  ): Promise<void> {
    const specVersion = getOpenAPISpecVersion(specObject)
    if (!specVersion) {
      throw new Error422UnprocessableEntity(
        "Invalid OpenAPI Spec: No 'swagger' or 'openapi' field defined.",
      )
    }
    const validationErrors = validateSpecSchema(specObject)
    if (validationErrors?.length > 0) {
      throw new Error422UnprocessableEntity("Invalid OpenAPI Spec", {
        message: "Invalid OpenAPI Spec",
        errors: validationErrors,
      })
    }
    await this.deleteSpec(fileName)
    await this.uploadNewSpec(specObject, fileName, extension, specString)
  }

  static async deleteSpec(fileName: string): Promise<void> {
    const apiEndpointRepository = AppDataSource.getRepository(ApiEndpoint)
    const openApiSpecRepository = AppDataSource.getRepository(OpenApiSpec)

    const specEndpoints = await apiEndpointRepository.findBy({
      openapiSpecName: fileName,
    })
    const openApiSpec = await openApiSpecRepository.findOneBy({
      name: fileName,
    })
    if (!openApiSpec) {
      throw new Error404NotFound("No spec file with the provided name exists.")
    }
    if (openApiSpec.isAutoGenerated) {
      throw new Error409Conflict("Can't delete auto generated spec.")
    }
    for (let i = 0; i < specEndpoints.length; i++) {
      const endpoint = specEndpoints[i]
      endpoint.openapiSpecName = null
    }
    await DatabaseService.executeTransactions([specEndpoints], [[openApiSpec]])
  }

  static async uploadNewSpec(
    specObject: JSONValue,
    fileName: string,
    extension: SpecExtension,
    specString: string,
  ): Promise<void> {
    const specVersion = getOpenAPISpecVersion(specObject)
    if (!specVersion) {
      throw new Error422UnprocessableEntity(
        "Invalid OpenAPI Spec: No 'swagger' or 'openapi' field defined.",
      )
    }
    const validationErrors = validateSpecSchema(specObject, specVersion)
    if (validationErrors?.length > 0) {
      throw new Error422UnprocessableEntity("Invalid OpenAPI Spec", {
        message: "Invalid OpenAPI Spec",
        errors: validationErrors,
      })
    }
    const paths: JSONValue = specObject["paths"]

    const apiEndpointRepository = AppDataSource.getRepository(ApiEndpoint)
    const openApiSpecRepository = AppDataSource.getRepository(OpenApiSpec)
    const apiTraceRepository = AppDataSource.getRepository(ApiTrace)
    const aggregateTraceDataRepository =
      AppDataSource.getRepository(AggregateTraceData)

    let existingSpec = await openApiSpecRepository.findOneBy({
      name: fileName,
    })
    if (!existingSpec) {
      existingSpec = new OpenApiSpec()
      existingSpec.name = fileName
      existingSpec.extension = extension
    }
    existingSpec.spec = specString
    const pathKeys = Object.keys(paths)
    const endpoints: {
      similarEndpoints: ApiEndpoint[]
      apiEndpoints: ApiEndpoint[]
      traces: ApiTrace[]
      aggregateData: AggregateTraceData[]
      dataFields: DataField[]
      alertsToKeep: Alert[]
      alertsToRemove: Alert[]
    } = {
      similarEndpoints: [],
      apiEndpoints: [],
      traces: [],
      aggregateData: [],
      dataFields: [],
      alertsToKeep: [],
      alertsToRemove: [],
    }
    let specHosts: Set<string> = new Set()
    for (const path of pathKeys) {
      const pathRegex = getPathRegex(path)
      const methods = Object.keys(paths[path])?.filter(key =>
        Object.values(RestMethod).includes(key.toUpperCase() as RestMethod),
      )
      for (const method of methods) {
        let hosts: Set<string> = new Set()
        const servers = getServersV3(specObject, path, method)
        if (!servers || servers?.length === 0) {
          throw new Error422UnprocessableEntity(
            "No servers found in spec file.",
          )
        }
        hosts = getHostsV3(servers)
        specHosts = new Set([...specHosts, ...hosts])
        for (const host of hosts) {
          // For exact endpoint match
          let updated = false
          const methodEnum = method.toUpperCase() as RestMethod
          let apiEndpoint = await apiEndpointRepository.findOne({
            where: {
              path,
              method: methodEnum,
              host,
            },
            relations: { openapiSpec: true },
          })
          if (!apiEndpoint) {
            apiEndpoint = new ApiEndpoint()
            apiEndpoint.uuid = uuidv4()
            apiEndpoint.path = path
            apiEndpoint.pathRegex = pathRegex
            apiEndpoint.method = methodEnum
            apiEndpoint.host = host
            apiEndpoint.totalCalls = 0
            apiEndpoint.openapiSpec = existingSpec
            updated = true
          } else if (
            apiEndpoint &&
            (!apiEndpoint.openapiSpecName ||
              apiEndpoint.openapiSpec?.isAutoGenerated)
          ) {
            apiEndpoint.openapiSpec = existingSpec
            updated = true
          } else {
            throw new Error409Conflict(
              `Path ${apiEndpoint.path} defined in the given new spec file is already defined in another user defined spec file: ${apiEndpoint.openapiSpecName}`,
            )
          }
          endpoints.apiEndpoints.push(apiEndpoint)

          if (updated) {
            const similarEndpoints = await apiEndpointRepository.find({
              where: {
                path: Not(path),
                pathRegex,
                method: methodEnum,
                host,
              },
              relations: {
                dataFields: true,
                alerts: true,
              },
              order: {
                riskScore: "ASC",
              },
            })
            if (similarEndpoints) {
              for (const endpoint of similarEndpoints) {
                apiEndpoint.totalCalls += endpoint.totalCalls
                apiEndpoint.riskScore = endpoint.riskScore
                const traces = await apiTraceRepository.findBy({
                  apiEndpointUuid: endpoint.uuid,
                })
                const aggregateData = await aggregateTraceDataRepository.findBy(
                  {
                    apiEndpointUuid: endpoint.uuid,
                  },
                )
                endpoint.dataFields.forEach(dataField => {
                  dataField.apiEndpointUuid = apiEndpoint.uuid
                })
                traces.forEach(trace => {
                  trace.apiEndpointUuid = apiEndpoint.uuid
                  apiEndpoint.updateDates(trace.createdAt)
                })
                aggregateData.forEach(
                  data => (data.apiEndpointUuid = apiEndpoint.uuid),
                )
                endpoint.alerts.forEach(alert => {
                  switch (alert.type) {
                    case AlertType.NEW_ENDPOINT:
                    case AlertType.OPEN_API_SPEC_DIFF:
                      endpoints.alertsToRemove.push(alert)
                      break
                    case AlertType.PII_DATA_DETECTED:
                    case AlertType.QUERY_SENSITIVE_DATA:
                    case AlertType.BASIC_AUTHENTICATION_DETECTED:
                    default:
                      alert.apiEndpointUuid = apiEndpoint.uuid
                      endpoints.alertsToKeep.push(alert)
                  }
                })
                endpoints.traces.push(...traces)
                endpoints.aggregateData.push(...aggregateData)
                endpoints.dataFields.push(...endpoint.dataFields)
              }
              endpoints.similarEndpoints.push(...similarEndpoints)
            }
          }
        }
      }
    }
    existingSpec.hosts = [...specHosts]
    await DatabaseService.executeTransactions(
      [
        [existingSpec],
        endpoints.apiEndpoints,
        endpoints.traces,
        endpoints.aggregateData,
        endpoints.dataFields,
        endpoints.alertsToKeep,
      ],
      [endpoints.alertsToRemove, endpoints.similarEndpoints],
      true,
    )
  }

  static async findOpenApiSpecDiff(
    trace: ApiTrace,
    endpoint: ApiEndpoint,
  ): Promise<Alert[]> {
    try {
      const openApiSpecRepository = AppDataSource.getRepository(OpenApiSpec)
      const openApiSpec = await openApiSpecRepository.findOneBy({
        name: endpoint.openapiSpecName,
      })
      if (!openApiSpec || openApiSpec?.isAutoGenerated) {
        return []
      }
      const blockFieldEntry = await BlockFieldsService.getBlockFieldsEntry(
        trace,
      )
      const specObject: JSONValue = yaml.load(openApiSpec.spec) as JSONValue
      const parsedSpec = await SwaggerParser.dereference(specObject as any)
      const specPath =
        parsedSpec.paths?.[endpoint.path]?.[endpoint.method.toLowerCase()]

      // Validate request info
      const specRequestParameters = getSpecRequestParameters(
        parsedSpec,
        endpoint,
      )
      const specRequestBody: SpecValue = getSpecRequestBody(
        parsedSpec,
        endpoint,
      )
      const requestValidator = new OpenAPIRequestValidator({
        parameters: specRequestParameters?.value,
        requestBody: specRequestBody?.value,
        schemas: parsedSpec?.["components"]?.["schemas"] ?? {},
        errorTransformer: (error, ajvError) => {
          return ajvError
        },
        additionalQueryProperties: false,
        enableHeadersLowercase: true,
      })
      const headers = {}
      const body = parsedJsonNonNull(trace.requestBody)
      const query = {}
      const endpointPathTokens = getPathTokens(endpoint.path)
      const tracePathTokens = getPathTokens(trace.path)
      const pathParams = {}
      for (let i = 0; i < endpointPathTokens.length; i++) {
        const currToken = endpointPathTokens[i]
        if (isParameter(currToken)) {
          pathParams[currToken.slice(1, -1)] = parsePathParameter(
            tracePathTokens[i],
          )
        }
      }
      trace.requestHeaders.forEach(
        header => (headers[header.name] = header.value),
      )
      trace.requestParameters.forEach(
        parameter =>
          (query[parameter.name] = parsedJsonNonNull(parameter.value, true)),
      )
      const traceRequest = {
        headers,
        body,
        query,
        params: pathParams,
      }
      const requestErrors: AjvError[] =
        requestValidator.validateRequest(traceRequest)?.errors
      const reqErrorItems = generateAlertMessageFromReqErrors(
        requestErrors,
        specRequestParameters.path,
        specRequestBody.path,
        specRequestParameters.value,
        blockFieldEntry?.disabledPaths ?? [],
      )

      // Validate response info
      const responses = getSpecResponses(parsedSpec, endpoint)
      const responseValidator = new OpenAPIResponseValidator({
        components: specObject["components"],
        responses: responses?.value,
        errorTransformer: (error, ajvError) => {
          return ajvError
        },
      })
      const traceStatusCode = trace.responseStatus
      const resHeaders = trace.responseHeaders.reduce(
        (obj, item) => ((obj[item.name] = item.value), obj),
        {},
      )
      const traceResponseBody = parsedJsonNonNull(trace.responseBody, true)
      const responseValidationItems: OpenAPIResponseValidatorValidationError =
        responseValidator.validateResponse(
          traceStatusCode,
          traceResponseBody,
          resHeaders,
        )
      const responseErrors = responseValidationItems?.errors
      const respErrorItems = generateAlertMessageFromRespErrors(
        responseErrors as AjvError[],
        responses?.path,
        blockFieldEntry?.disabledPaths ?? [],
      )

      const errorItems = { ...reqErrorItems, ...respErrorItems }
      return await AlertService.createSpecDiffAlerts(
        errorItems,
        endpoint.uuid,
        trace,
        openApiSpec.spec,
        openApiSpec.extension,
      )
    } catch (err) {
      console.error(`Error finding OpenAPI Spec diff: ${err}`)
      return []
    }
  }
}
